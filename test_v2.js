"use strict";

const axios = require('axios');
const TelegramBot = require('node-telegram-bot-api');
const fs = require('fs');
const path = require('path');

// =========================================================================
// CONFIGURACI√ìN (tu configuraci√≥n actual)
// =========================================================================
const telegram = {
  botToken: "7325587317:AAEi3O2F2CckkIeOnmJkqXxcxRTxfNikqOQ",
  chatId: "-1002513153868"
};

// =========================================================================
// TWITTER API GRATUITA (usando endpoints p√∫blicos)
// =========================================================================
class FreeTwitterAPI {
  constructor() {
    this.rateLimitDelay = 2000; // 2 segundos entre requests
    this.lastRequest = 0;
  }

  async waitForRateLimit() {
    const now = Date.now();
    const timeSinceLastRequest = now - this.lastRequest;
    if (timeSinceLastRequest < this.rateLimitDelay) {
      await new Promise(resolve => setTimeout(resolve, this.rateLimitDelay - timeSinceLastRequest));
    }
    this.lastRequest = Date.now();
  }

  async getUserInfo(username) {
    try {
      await this.waitForRateLimit();
      
      // Intentar con endpoint p√∫blico de Twitter
      const response = await axios.get('https://cdn.syndication.twimg.com/widgets/followbutton/info.json', {
        params: { screen_names: username },
        timeout: 10000,
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
      });

      if (response.data && response.data.length > 0) {
        const user = response.data[0];
        return {
          success: true,
          data: {
            id: user.id,
            userName: user.screen_name,
            name: user.name,
            description: user.description || 'Sin descripci√≥n',
            followers: user.followers_count || 0,
            following: user.friends_count || 0,
            statusesCount: user.statuses_count || 0,
            location: user.location || 'No especificada',
            isVerified: user.verified || false,
            profileImage: user.profile_image_url || ''
          }
        };
      }

      return { success: false, error: 'Usuario no encontrado' };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  // Simulador de tweets para demostraci√≥n
  async getUserTweets(username) {
    try {
      await this.waitForRateLimit();

      // Como no podemos obtener tweets reales gratis, simularemos algunos
      const simulatedTweets = [
        {
          id: Date.now().toString(),
          text: `üî• Tweet simulado de @${username} - ${new Date().toLocaleTimeString()}`,
          createdAt: new Date().toISOString(),
          likeCount: Math.floor(Math.random() * 1000),
          retweetCount: Math.floor(Math.random() * 500),
          replyCount: Math.floor(Math.random() * 100),
          isSimulated: true
        },
        {
          id: (Date.now() - 3600000).toString(),
          text: `üìù Otro tweet simulado para probar el sistema de notificaciones`,
          createdAt: new Date(Date.now() - 3600000).toISOString(),
          likeCount: Math.floor(Math.random() * 500),
          retweetCount: Math.floor(Math.random() * 200),
          replyCount: Math.floor(Math.random() * 50),
          isSimulated: true
        }
      ];

      return {
        success: true,
        tweets: simulatedTweets
      };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  async searchTweets(query) {
    // Simulaci√≥n de b√∫squeda
    return {
      success: true,
      tweets: [
        {
          id: Date.now().toString(),
          text: `Resultado simulado para: ${query}`,
          createdAt: new Date().toISOString(),
          likeCount: Math.floor(Math.random() * 100),
          retweetCount: Math.floor(Math.random() * 50),
          replyCount: Math.floor(Math.random() * 25),
          author: { userName: 'simulateduser' },
          isSimulated: true
        }
      ]
    };
  }
}

// =========================================================================
// SISTEMA DE LOGS Y ESTADO (igual que antes)
// =========================================================================
class MonitorSystem {
  constructor() {
    this.isMonitorActive = false;
    this.monitoredAccounts = new Map();
    this.lastTweetIds = new Map();
    this.monitorInterval = null;
    this.checkIntervalMs = 60000; // 1 minuto para la versi√≥n gratuita
    this.dataFile = path.join(__dirname, 'monitor_data.json');
    this.logFile = path.join(__dirname, 'monitor.log');
    
    this.loadData();
  }

  log(message, level = 'INFO') {
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] ${level}: ${message}`;
    console.log(logEntry);
    
    try {
      fs.appendFileSync(this.logFile, logEntry + '\n');
    } catch (error) {
      console.error('Error escribiendo log:', error);
    }
  }

  loadData() {
    try {
      if (fs.existsSync(this.dataFile)) {
        const data = JSON.parse(fs.readFileSync(this.dataFile, 'utf8'));
        this.monitoredAccounts = new Map(data.monitoredAccounts || []);
        this.lastTweetIds = new Map(data.lastTweetIds || []);
        this.log(`Datos cargados: ${this.monitoredAccounts.size} cuentas`);
      }
    } catch (error) {
      this.log(`Error cargando datos: ${error.message}`, 'ERROR');
    }
  }

  saveData() {
    try {
      const data = {
        monitoredAccounts: Array.from(this.monitoredAccounts.entries()),
        lastTweetIds: Array.from(this.lastTweetIds.entries()),
        lastSaved: new Date().toISOString()
      };
      fs.writeFileSync(this.dataFile, JSON.stringify(data, null, 2));
    } catch (error) {
      this.log(`Error guardando datos: ${error.message}`, 'ERROR');
    }
  }

  addAccount(username, settings = { receiveTweets: true, receiveRetweets: true }) {
    this.monitoredAccounts.set(username, settings);
    this.saveData();
    this.log(`Cuenta a√±adida: @${username}`);
  }

  getMonitoredAccounts() {
    return Array.from(this.monitoredAccounts.keys());
  }

  updateLastTweetId(username, tweetId) {
    this.lastTweetIds.set(username, tweetId);
    this.saveData();
  }

  getLastTweetId(username) {
    return this.lastTweetIds.get(username) || null;
  }
}

// =========================================================================
// MONITOR CON API GRATUITA
// =========================================================================
class FreeTwitterMonitor {
  constructor() {
    this.twitterAPI = new FreeTwitterAPI();
    this.metrics = {
      tweetsDetected: 0,
      tweetsSent: 0,
      errors: 0,
      startTime: null
    };
  }

  async startMonitoring() {
    if (monitor.isMonitorActive) {
      return { success: false, message: 'Monitor ya est√° activo' };
    }

    const accounts = monitor.getMonitoredAccounts();
    if (accounts.length === 0) {
      return { success: false, message: 'No hay cuentas para monitorear' };
    }

    monitor.isMonitorActive = true;
    this.metrics.startTime = new Date();
    
    monitor.log(`üöÄ MONITOR GRATUITO INICIADO - ${accounts.length} cuentas`);
    monitor.log(`üîÑ Verificando cada ${monitor.checkIntervalMs / 1000} segundos`);

    // Iniciar bucle
    monitor.monitorInterval = setInterval(() => {
      this.checkAllAccounts();
    }, monitor.checkIntervalMs);

    // Notificaci√≥n inicial
    const message = `üöÄ <b>Monitor Gratuito Iniciado</b>\n\n` +
      `üì± Cuentas: ${accounts.length}\n` +
      `‚è∞ Frecuencia: cada ${monitor.checkIntervalMs / 1000}s\n` +
      `üîî Modo: Simulaci√≥n/Demo\n` +
      `üí° Para tweets reales, configura una API\n\n` +
      `<i>Cuentas: ${accounts.map(a => '@' + a).join(', ')}</i>`;

    await sendTelegramMessage(message);

    return { success: true, message: `Monitor iniciado para ${accounts.length} cuentas` };
  }

  async pauseMonitoring() {
    if (!monitor.isMonitorActive) {
      return { success: false, message: 'Monitor no est√° activo' };
    }

    monitor.isMonitorActive = false;
    if (monitor.monitorInterval) {
      clearInterval(monitor.monitorInterval);
      monitor.monitorInterval = null;
    }

    monitor.log('‚è∏Ô∏è MONITOR PAUSADO');
    
    const uptime = this.metrics.startTime ? 
      Math.floor((Date.now() - this.metrics.startTime.getTime()) / 1000) : 0;

    const message = `‚è∏Ô∏è <b>Monitor Pausado</b>\n\n` +
      `üìä Estad√≠sticas:\n` +
      `‚Ä¢ Tweets detectados: ${this.metrics.tweetsDetected}\n` +
      `‚Ä¢ Tweets enviados: ${this.metrics.tweetsSent}\n` +
      `‚Ä¢ Errores: ${this.metrics.errors}\n` +
      `‚Ä¢ Tiempo activo: ${this.formatUptime(uptime)}`;

    await sendTelegramMessage(message);

    return { success: true, message: 'Monitor pausado' };
  }

  async checkAllAccounts() {
    if (!monitor.isMonitorActive) return;

    const accounts = monitor.getMonitoredAccounts();
    monitor.log(`üîç Verificando ${accounts.length} cuentas (modo gratuito)...`);

    for (const username of accounts) {
      try {
        await this.checkAccountTweets(username);
        await new Promise(resolve => setTimeout(resolve, 3000)); // Espera entre cuentas
      } catch (error) {
        this.metrics.errors++;
        monitor.log(`‚ùå Error verificando @${username}: ${error.message}`, 'ERROR');
      }
    }
  }

  async checkAccountTweets(username) {
    try {
      monitor.log(`üîç Verificando @${username}...`);

      const result = await this.twitterAPI.getUserTweets(username);
      
      if (!result.success || !result.tweets) {
        return;
      }

      const tweets = result.tweets;
      const lastKnownTweetId = monitor.getLastTweetId(username);
      const newTweets = this.filterNewTweets(tweets, lastKnownTweetId);

      if (newTweets.length > 0) {
        monitor.log(`üìù @${username}: ${newTweets.length} tweets nuevos (simulados)`);
        
        for (const tweet of newTweets.reverse()) {
          await this.processTweet(tweet, username);
        }

        monitor.updateLastTweetId(username, tweets[0].id);
      }

    } catch (error) {
      throw new Error(`Error API para @${username}: ${error.message}`);
    }
  }

  filterNewTweets(tweets, lastKnownTweetId) {
    if (!lastKnownTweetId) {
      return tweets.slice(0, 1); // Solo el m√°s reciente la primera vez
    }

    const newTweets = [];
    for (const tweet of tweets) {
      if (tweet.id === lastKnownTweetId) {
        break;
      }
      newTweets.push(tweet);
    }

    return newTweets;
  }

  async processTweet(tweet, username) {
    try {
      const settings = monitor.monitoredAccounts.get(username);
      
      // Formatear mensaje
      const message = this.formatTweetMessage(tweet, username);
      
      // Enviar a Telegram
      await sendTelegramMessage(message);
      
      this.metrics.tweetsDetected++;
      this.metrics.tweetsSent++;

      monitor.log(`‚úÖ Tweet simulado enviado: @${username} - ${tweet.id}`);

    } catch (error) {
      this.metrics.errors++;
      monitor.log(`‚ùå Error procesando tweet: ${error.message}`, 'ERROR');
    }
  }

  formatTweetMessage(tweet, username) {
    const icon = tweet.isSimulated ? "üß™" : "üìù";
    const prefix = tweet.isSimulated ? " (DEMO)" : "";
    
    let message = `${icon} <b>@${username}</b> public√≥${prefix}:\n\n`;
    message += `üí¨ ${tweet.text}\n\n`;
    message += `üìÖ ${this.formatDate(tweet.createdAt)}\n`;
    message += `‚ù§Ô∏è ${tweet.likeCount} | üîÑ ${tweet.retweetCount} | üí¨ ${tweet.replyCount}`;
    
    if (tweet.isSimulated) {
      message += `\n\nüîß <i>Simulaci√≥n - Configura una API real para tweets verdaderos</i>`;
    }
    
    return message;
  }

  formatDate(dateString) {
    try {
      return new Date(dateString).toLocaleString('es-ES', {
        day: '2-digit',
        month: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
    } catch {
      return 'Fecha inv√°lida';
    }
  }

  formatUptime(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    if (hours > 0) return `${hours}h ${minutes}m`;
    if (minutes > 0) return `${minutes}m`;
    return `${seconds}s`;
  }

  getMetrics() {
    const uptime = this.metrics.startTime ? 
      Math.floor((Date.now() - this.metrics.startTime.getTime()) / 1000) : 0;
    
    return {
      ...this.metrics,
      uptime,
      isActive: monitor.isMonitorActive
    };
  }
}

// =========================================================================
// CONFIGURACI√ìN DEL BOT DE TELEGRAM
// =========================================================================
const bot = new TelegramBot(telegram.botToken, { polling: true });
const monitor = new MonitorSystem();
const twitterMonitor = new FreeTwitterMonitor();

async function sendTelegramMessage(message) {
  try {
    await bot.sendMessage(telegram.chatId, message, { parse_mode: "HTML" });
  } catch (error) {
    monitor.log(`Error enviando mensaje: ${error.message}`, 'ERROR');
    throw error;
  }
}

function sendTelegramMenu(chatId) {
  const accounts = monitor.getMonitoredAccounts();
  const metrics = twitterMonitor.getMetrics();
  
  const menuMessage = `ü§ñ <b>Monitor de Twitter - Versi√≥n Gratuita</b>\n\n` +
    `üìä Estado: ${metrics.isActive ? 'üü¢ Activo' : 'üî¥ Inactivo'}\n` +
    `üì± Cuentas: ${accounts.length}\n` +
    `üìù Tweets enviados: ${metrics.tweetsSent}\n` +
    `üîß Modo: Demo/Simulaci√≥n\n\n` +
    `Selecciona una opci√≥n:`;

  const options = {
    reply_markup: {
      inline_keyboard: [
        [
          { 
            text: metrics.isActive ? "‚è∏Ô∏è Pausar Monitor" : "‚ñ∂Ô∏è Iniciar Monitor", 
            callback_data: metrics.isActive ? "pause_monitor" : "start_monitor" 
          }
        ],
        [
          { text: "‚ûï A√±adir Cuenta", callback_data: "add_account" },
          { text: "üì± Ver Cuentas", callback_data: "list_accounts" }
        ],
        [
          { text: "üìä Estad√≠sticas", callback_data: "stats" },
          { text: "üîç Info Usuario", callback_data: "user_info" }
        ],
        [
          { text: "üß™ Tweet de Prueba", callback_data: "test_tweet" },
          { text: "‚ùì Ayuda", callback_data: "help" }
        ],
        [
          { text: "üîß Configurar API Real", callback_data: "setup_api" }
        ]
      ]
    }
  };

  bot.sendMessage(chatId, menuMessage, { parse_mode: "HTML", ...options });
}

// =========================================================================
// MANEJADORES DE COMANDOS
// =========================================================================
bot.onText(/\/start/, async (msg) => {
  const chatId = msg.chat.id;
  
  const welcomeMessage = `üöÄ <b>¬°Bienvenido al Monitor de Twitter!</b>\n\n` +
    `üîß <b>Versi√≥n Gratuita/Demo</b>\n\n` +
    `Esta versi√≥n funciona con simulaciones para que puedas probar el sistema sin APIs de pago.\n\n` +
    `<b>üéØ Caracter√≠sticas:</b>\n` +
    `‚Ä¢ Monitor autom√°tico cada minuto\n` +
    `‚Ä¢ Informaci√≥n real de usuarios\n` +
    `‚Ä¢ Tweets simulados para demo\n` +
    `‚Ä¢ Todas las funciones del men√∫\n\n` +
    `<b>üîß Para tweets reales:</b>\n` +
    `Configura una API de Twitter (te ayudo en el men√∫)\n\n` +
    `üëá Usa el men√∫ para empezar:`;

  await bot.sendMessage(chatId, welcomeMessage, { parse_mode: "HTML" });
  sendTelegramMenu(chatId);
});

bot.onText(/\/add (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const username = match[1].replace('@', '').trim();
  
  try {
    const twitterAPI = new FreeTwitterAPI();
    const userInfo = await twitterAPI.getUserInfo(username);

    if (userInfo.success) {
      monitor.addAccount(username);
      
      const userData = userInfo.data;
      const message = `‚úÖ <b>Cuenta a√±adida exitosamente</b>\n\n` +
        `üë§ @${userData.userName}\n` +
        `üìù ${userData.name}\n` +
        `üë• ${userData.followers?.toLocaleString() || 0} seguidores\n` +
        `üìç ${userData.location}\n\n` +
        `üîî Ser√° monitoreada cuando inicies el monitor.\n` +
        `üß™ Recibir√°s tweets simulados en modo demo.`;
      
      await bot.sendMessage(chatId, message, { parse_mode: "HTML" });
    } else {
      await bot.sendMessage(chatId, `‚ùå Usuario @${username} no encontrado o error: ${userInfo.error}`);
    }
  } catch (error) {
    await bot.sendMessage(chatId, `‚ùå Error verificando usuario: ${error.message}`);
  }
});

bot.onText(/\/stats/, async (msg) => {
  const chatId = msg.chat.id;
  const metrics = twitterMonitor.getMetrics();
  const accounts = monitor.getMonitoredAccounts();
  
  const statsMessage = `üìä <b>Estad√≠sticas del Monitor</b>\n\n` +
    `üîÑ <b>Estado:</b> ${metrics.isActive ? 'üü¢ Activo' : 'üî¥ Inactivo'}\n` +
    `‚è∞ <b>Tiempo activo:</b> ${twitterMonitor.formatUptime(metrics.uptime)}\n` +
    `üìù <b>Tweets detectados:</b> ${metrics.tweetsDetected}\n` +
    `üì§ <b>Tweets enviados:</b> ${metrics.tweetsSent}\n` +
    `‚ùå <b>Errores:</b> ${metrics.errors}\n` +
    `üì± <b>Cuentas monitoreadas:</b> ${accounts.length}\n` +
    `üîç <b>Frecuencia:</b> cada ${monitor.checkIntervalMs / 1000}s\n` +
    `üîß <b>Modo:</b> Demo/Simulaci√≥n\n\n` +
    `üìà <b>Eficiencia:</b> ${metrics.tweetsDetected > 0 ? 
      Math.round((metrics.tweetsSent / metrics.tweetsDetected) * 100) : 100}%`;

  await bot.sendMessage(chatId, statsMessage, { parse_mode: "HTML" });
});

// =========================================================================
// MANEJO DE CALLBACKS
// =========================================================================
bot.on('callback_query', async (callbackQuery) => {
  const chatId = callbackQuery.message.chat.id;
  const data = callbackQuery.data;

  try {
    switch (data) {
      case "start_monitor":
        const startResult = await twitterMonitor.startMonitoring();
        if (!startResult.success) {
          await bot.sendMessage(chatId, `‚ùå ${startResult.message}`);
        }
        break;

      case "pause_monitor":
        const pauseResult = await twitterMonitor.pauseMonitoring();
        if (!pauseResult.success) {
          await bot.sendMessage(chatId, `‚ùå ${pauseResult.message}`);
        }
        break;

      case "add_account":
        await bot.sendMessage(chatId, 
          "‚ûï <b>A√±adir Cuenta</b>\n\n" +
          "Env√≠a el nombre de usuario sin @:\n" +
          "Ejemplo: <code>elonmusk</code>\n\n" +
          "O usa: <code>/add usuario</code>", 
          { parse_mode: "HTML" }
        );
        break;

      case "list_accounts":
        await handleListAccounts(chatId);
        break;

      case "stats":
        await bot.sendMessage(chatId, '/stats');
        break;

      case "user_info":
        await handleUserInfo(chatId);
        break;

      case "test_tweet":
        await handleTestTweet(chatId);
        break;

      case "setup_api":
        await handleSetupAPI(chatId);
        break;

      case "help":
        await handleHelp(chatId);
        break;

      default:
        await bot.sendMessage(chatId, "‚ùì Opci√≥n no reconocida.");
    }
  } catch (error) {
    monitor.log(`‚ùå Error en callback: ${error.message}`, 'ERROR');
    await bot.sendMessage(chatId, "‚ùå Error procesando la solicitud.");
  }

  await bot.answerCallbackQuery(callbackQuery.id);
  setTimeout(() => sendTelegramMenu(chatId), 2000);
});

// =========================================================================
// FUNCIONES AUXILIARES
// =========================================================================
async function handleListAccounts(chatId) {
  const accounts = monitor.getMonitoredAccounts();
  CONFIG.telegram.botToken
  if (accounts.length === 0) {
    await bot.sendMessage(chatId, 
      "üì± No hay cuentas monitoreadas.\n\n" +
      "Usa ‚ûï A√±adir Cuenta o env√≠a:\n" +
      "<code>/add username</code>", 
      { parse_mode: "HTML" }
    );
    return;
  }

  let message = "üì± <b>Cuentas Monitoreadas:</b>\n\n";
  
  for (const username of accounts) {
    const settings = monitor.monitoredAccounts.get(username);
    const lastTweetId = monitor.lastTweetIds.get(username);
    
    message += `üë§ <b>@${username}</b>\n`;
    message += `  üìù Tweets: ${settings.receiveTweets ? "‚úÖ" : "‚ùå"}\n`;
    message += `  üîÑ Retweets: ${settings.receiveRetweets ? "‚úÖ" : "‚ùå"}\n`;
    message += `  üìä √öltimo tweet: ${lastTweetId ? "‚úÖ" : "‚ùå"}\n\n`;
  }

  message += `üîß <i>Modo: Demo/Simulaci√≥n</i>`;

  await bot.sendMessage(chatId, message, { parse_mode: "HTML" });
}

async function handleUserInfo(chatId) {
  await bot.sendMessage(chatId, 
    "üë§ <b>Informaci√≥n de Usuario</b>\n\n" +
    "Env√≠a el nombre de usuario (sin @):",
    { parse_mode: "HTML" }
  );

  bot.once('message', async (reply) => {
    const username = reply.text.trim();
    const twitterAPI = new FreeTwitterAPI();
    
    try {
      const userInfo = await twitterAPI.getUserInfo(username);
      
      if (userInfo.success) {
        const user = userInfo.data;
        const message = `üë§ <b>@${user.userName}</b>\n\n` +
          `üìù <b>Nombre:</b> ${user.name}\n` +
          `üÜî <b>ID:</b> ${user.id}\n` +
          `üìç <b>Ubicaci√≥n:</b> ${user.location}\n` +
          `üìÑ <b>Descripci√≥n:</b> ${user.description}\n` +
          `üë• <b>Seguidores:</b> ${user.followers?.toLocaleString()}\n` +
          `üë£ <b>Siguiendo:</b> ${user.following?.toLocaleString()}\n` +
          `üìù <b>Tweets:</b> ${user.statusesCount?.toLocaleString()}\n` +
          `‚úÖ <b>Verificado:</b> ${user.isVerified ? 'S√≠' : 'No'}`;
        
        await bot.sendMessage(chatId, message, { parse_mode: "HTML" });
      } else {
        await bot.sendMessage(chatId, `‚ùå Error: ${userInfo.error}`);
      }
    } catch (error) {
      await bot.sendMessage(chatId, `‚ùå Error obteniendo informaci√≥n: ${error.message}`);
    }
  });
}

async function handleTestTweet(chatId) {
  try {
    const testTweet = {
      id: Date.now().toString(),
      text: 'üß™ Este es un tweet de PRUEBA para demostrar c√≥mo funciona el sistema de notificaciones en tiempo real!',
      createdAt: new Date().toISOString(),
      likeCount: Math.floor(Math.random() * 500),
      retweetCount: Math.floor(Math.random() * 100),
      replyCount: Math.floor(Math.random() * 50),
      isSimulated: true
    };

    const message = `üß™ <b>@testuser</b> public√≥ (DEMO):\n\n` +
      `üí¨ ${testTweet.text}\n\n` +
      `üìÖ ${twitterMonitor.formatDate(testTweet.createdAt)}\n` +
      `‚ù§Ô∏è ${testTweet.likeCount} | üîÑ ${testTweet.retweetCount} | üí¨ ${testTweet.replyCount}\n\n` +
      `üîß <i>As√≠ se ver√°n las notificaciones reales</i>`;

    await bot.sendMessage(chatId, message, { parse_mode: "HTML" });
  } catch (error) {
    await bot.sendMessage(chatId, `‚ùå Error enviando tweet de prueba: ${error.message}`);
  }
}

async function handleSetupAPI(chatId) {
  const setupMessage = `üîß <b>Configurar API Real de Twitter</b>\n\n` +
    `Para recibir tweets reales (no simulados), necesitas una API de Twitter:\n\n` +
    `<b>üÜì OPCI√ìN 1: Twitter API Oficial (GRATIS)</b>\n` +
    `‚Ä¢ 500,000 tweets/mes gratis\n` +
    `‚Ä¢ Ve a: developer.twitter.com\n` +
    `‚Ä¢ Crea una app y obt√©n Bearer Token\n\n` +
    `<b>üí∞ OPCI√ìN 2: RapidAPI (PAGO)</b>\n` +
    `‚Ä¢ Desde $5-10/mes\n` +
    `‚Ä¢ Ve a: rapidapi.com\n` +
    `‚Ä¢ Busca "Twitter API"\n\n` +
    `<b>üîß CONFIGURACI√ìN:</b>\n` +
    `1. Obt√©n tu token/key\n` +
    `2. Edita el archivo app.js\n` +
    `3. Reemplaza FreeTwitterAPI por la API real\n` +
    `4. Reinicia el bot\n\n` +
    `<b>üí° ¬øNecesitas ayuda?</b>\n` +
    `Te puedo guiar paso a paso para configurar cualquier API.`;

  await bot.sendMessage(chatId, setupMessage, { parse_mode: "HTML" });
}

async function handleHelp(chatId) {
  const helpMessage = `‚ùì <b>Ayuda - Monitor de Twitter Gratuito</b>\n\n` +
    `<b>üéØ ¬øQu√© hace esta versi√≥n?</b>\n` +
    `‚Ä¢ Monitorea cuentas de Twitter\n` +
    `‚Ä¢ Obtiene informaci√≥n real de usuarios\n` +
    `‚Ä¢ Simula tweets para demostrar funcionalidad\n` +
    `‚Ä¢ Te permite probar el sistema completo\n\n` +
    `<b>üìã Comandos disponibles:</b>\n` +
    `/start - Mostrar men√∫ principal\n` +
    `/add usuario - A√±adir cuenta\n` +
    `/stats - Ver estad√≠sticas\n\n` +
    `<b>üîÑ C√≥mo funciona:</b>\n` +
    `1. A√±ade cuentas con /add\n` +
    `2. Inicia el monitor con ‚ñ∂Ô∏è\n` +
    `3. Recibe notificaciones simuladas\n` +
    `4. Para tweets reales, configura una API\n\n` +
    `<b>üîß Limitaciones de la versi√≥n gratuita:</b>\n` +
    `‚Ä¢ Tweets simulados (no reales)\n` +
    `‚Ä¢ Verificaci√≥n cada minuto (no 30s)\n` +
    `‚Ä¢ Solo informaci√≥n b√°sica de usuarios\n\n` +
    `<b>‚úÖ Lo que S√ç funciona completamente:</b>\n` +
    `‚Ä¢ Sistema de monitoreo\n` +
    `‚Ä¢ Interfaz de Telegram\n` +
    `‚Ä¢ Estad√≠sticas y logs\n` +
    `‚Ä¢ Gesti√≥n de cuentas\n` +
    `‚Ä¢ Notificaciones autom√°ticas`;

  await bot.sendMessage(chatId, helpMessage, { parse_mode: "HTML" });
}

// =========================================================================
// INICIALIZACI√ìN
// =========================================================================
console.log('ü§ñ Twitter Monitor Bot - Versi√≥n Gratuita');
console.log('=====================================');
console.log('üìä Configuraci√≥n:');
console.log(`   ‚Ä¢ Bot Token: ${telegram.botToken.substring(0, 10)}...`);
console.log(`   ‚Ä¢ Chat ID: ${telegram.chatId}`);
console.log(`   ‚Ä¢ Archivo de datos: ${monitor.dataFile}`);
console.log(`   ‚Ä¢ Archivo de logs: ${monitor.logFile}`);
console.log(`   ‚Ä¢ Modo: Demo/Simulaci√≥n`);

bot.on('polling_error', (error) => {
  monitor.log(`Error de polling: ${error.message}`, 'ERROR');
});

process.on('SIGINT', () => {
  monitor.log('üõë Bot detenido por usuario');
  if (monitor.isMonitorActive) {
    twitterMonitor.pauseMonitoring();
  }
  monitor.saveData();
  process.exit(0);
});

process.on('uncaughtException', (error) => {
  monitor.log(`üí• Error no manejado: ${error.message}`, 'ERROR');
  monitor.saveData();
});

monitor.log('üöÄ Twitter Monitor Bot (Versi√≥n Gratuita) iniciado');
monitor.log(`üì± Cuentas cargadas: ${monitor.getMonitoredAccounts().length}`);

console.log('\n‚úÖ Bot iniciado correctamente!');
console.log('üì± Env√≠a /start a tu bot para comenzar');
console.log('üß™ Esta versi√≥n usa simulaciones para demo');
console.log('üîß Para tweets reales, configura una API de Twitter');
console.log('\nüéØ Funciones disponibles:');
console.log('   ‚Ä¢ /start - Men√∫ principal');
console.log('   ‚Ä¢ /add usuario - A√±adir cuenta');
console.log('   ‚Ä¢ /stats - Ver estad√≠sticas');
console.log('   ‚Ä¢ ‚ñ∂Ô∏è Iniciar monitor (simulado)');
console.log('   ‚Ä¢ üß™ Tweet de prueba');
console.log('\nüí° Los tweets ser√°n simulados hasta configurar API real\n');